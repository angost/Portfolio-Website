{
    "projects": [
        {
            "name": "Fish Simulation",
            "description_short": "Simulation of swimming and preying behaviour depending on fish speed, size, hunger.",
            "description_long": "Simple, fun project to simulate fish swimming in a closed environment. Created in Python using Pygame - library for games. Fish are represented as objects, with different types of fish being seperate subclasses (they differ in speed, size and looks). You can specify number of fish to spawn.\nWhen the simulation starts, spawned fish start to move around the screen, changing direction if they reach the edge. Each fish starts with a certain level of hunger, which gets higher by eating other fish and lower by swimming. It is represented by a colorful circle around the fish.\nWhen hunger becomes too low a method is called, which looks for nearest (smallest difference in x and y position) smaller fish. Then it targets it and changes movement pattern from free swimming to chasing targeted prey. When a fish gets eaten, it becomes a corpse and slowly falls down the screen. Attacker's hunger goes up, and it becomes larger.\nThere's also an option to spawn food next to mouse cursor by clicking its left button, and making all the fish follow the mouse cursor while right mouse button is pressed.",
            "img_paths": ["assets/images/fish.png"],
            "technologies": ["Python", "Pygame", "OOP"],
            "github_link": "",
            "people_no": "solo",
            "goal": "personal",
            "takeaways": [],
            "other": []
        },
        {
            "name": "Matches for Couples",
            "description_short": "Tool to find activities suitable for both people in a Tinder-like manner.",
            "description_long": "An app for two people (a couple) in which users are given a small number (5/10) of questions daily (they both get the same questions, which is achieved by generating a random set of questions and writing them to a shared github repository).\nA question is displayed on a card, frased like 'Would you like to have a picnic outside with your partner?'. A person can drag the card to one of four areas on the screen, representing willingness to do the activity ('very much', 'okay', 'definitely not', ' I can if you want to') which are converted into a number from 1 to 4.\nQuestions are coded and stored in a csv file (index, content). Answers are stored in a seperate csv file (index, person1answer, person2answer), which, after being updated with new answers, is pushed to a github repository. When the other user opens the app, any changes are pulled from the repo.\nUsers can then open a 'Matches' tab, on which all answered questions are displayed in a list, with a compatibility graph on the right. Answers can be sorted by date, by compatibility and marked as favourites. There is also an option to send a request - a custom question from one partner to another, which is marked as 4 (very likely to do it) for the sender, and ? for the receiver. The receiver will respond to the request during the next set of questions.",
            "img_paths": ["assets/images/matches.png"],
            "technologies": ["Python", "Pygame", "Git", "GitPython"],
            "github_link": "",
            "people_no": "solo",
            "goal": "personal",
            "takeaways": ["creating an app layout in pygame", "using gitpython library", "creating a product for 2 people, who use it remotely and share data"],
            "other": []
        },
        {
            "name": "Vehicle Renting (VeloC++ity)",
            "description_short": "Command line app in C++ simulating city Bikes and Scooters renting system.",
            "description_long": "A group project in C++. It provides the logic of city bikes and scooters renting system. There are 3 modes availible, for different types of users:\n- Client (who can create an account, deposit money on it, localise the nearest free vehicle, reserve it in advance, rent it, check for free spaces on the stations, return rented vehicle),\n- Service (technical support group, which can add/remove a vehicle, move vehicles between stations, fix a vehicle),\n- Admin (who can add/remove stations, add/remove vehicles from the system, manage service teams).\nThere are a couple types of vehicles (Bike, Electric Bike, Scooter, Electric Scooter), each of them inherits from an abstract Vehicle class.\nInformation on stations (stats, currently availible vehicles), users (stats, currently reserved and rented vehicles) etc. is stored in a group of txt files, in a complete and well-thought-out manner. Data is being updated so no conflicts emerge, like two clients renting the same bike at the same time (it is also covered inside the classes).",
            "img_paths": ["assets/images/menu.png"],
            "technologies": ["C++", "OOP", "Git"],
            "github_link": "",
            "people_no": "group",
            "goal": "university",
            "takeaways": ["using abstract classes, virtual functions, iterators, templates in C++", "saving app state to file, reading and updating it", "user identification, authentication, authorization"],
            "other": []
        },
        {
            "name": "Hotels Application (Sleeping.com)",
            "description_short": "Desktop app in Java - hotel rooms reservation system.",
            "description_long": "A group project in Java I was very passionate about. We created a desktop app for a reservation system which enabled:\n- for the Owner - adding new hotels and rooms in them, managing owner's property (modifying/removing), looking through and managing reservations, reviews, ...\n- for the Client - searching for rooms, seeing offer details, making a reservation, paying, prolonging/cancelling future reservations, adding reviews to past reservations, ...\nBefore that, User had to signing up/log in. All data about rooms, reservations, users, etc. was stored in a relatonal SQL database (using PostgreSQL) which we first planned using an ER model.\nMy job was mainly creating GUI, which was a huge part of the whole application and made me learn how to use Swing library.",
            "img_paths": ["assets/images/pap_hotels.png"],
            "technologies": ["Java", "Swing", "SQL", "Git"],
            "github_link": "",
            "people_no": "group",
            "goal": "university",
            "takeaways": ["using Swing to create desktop app GUI", "planning relational database structure (ER model)", "participating in a larger, more complex project", "designing app views in Figma"],
            "other": []
        },
        {
            "name": "Introduction to Artificial Intelligence (WSI labs)",
            "description_short": "Knapsack problem, Gradient descent, Genetic and Evolutionary algorithms, Two-person games, ID3, Artificial neural networks.",
            "description_long": "Series of practical laboratories for a university class. All of the exercises were implementing knowledge from the lectures, required implementing an algorithm and testing, observing how its parameters influence the quality of the result (with utilization of plots). Topics in detail: \n1. Knapsack problem - using profit/weight heuristic \n2. Gradient descent - finding function optimum (minimum) using simple gradient descent method \n3. Genetic and Evolutionary algorithms - finding function minimum with genetic algorithm; implementing chromosomes, genes, mutations, single-point crossover \n4. Two-person games - minmax algorithm with alpha-beta-pruning used on a ConnectFour game \n5. ID3 - using decision trees for Iris dataset classification \n6. Artificial neural networks - implementing neurons, layers (tanh and fully-connected), forward and backpropagation for MNIST written numbers dataset",
            "img_paths": ["assets/images/wsi.png"],
            "technologies": ["Python", "AI", "Numpy", "Matplotlib", "Google Colab, Jupyter Notebook"],
            "github_link": "",
            "people_no": "solo",
            "goal": "university",
            "takeaways": [""],
            "other": []
        },
        {
            "name": "Flood fill in RISC-V Assembly",
            "description_short": "Modify raster image by coloring an area. Made in Assembly for RISC-V.",
            "description_long": "Project for Computer Architecture course, concluding the learning of RISC-V Assembly and RARS simulator. There's access to 31 registers, with instructions and pseudoinstructions like loading ans storing, arithmetic and logical (with register/with immidiate), conditional and unconditional jumps, environment calls, using stack and dynamic allocation.\nThe goal was getting a small (e.g. 4x8, 20x20 pixels) raster image (its path), picking starting pixel (x,y coordinates) and color to paint the are with (R,G,B), processing it and returning modified image.\nImage format was a 24-bit bitmap, with 1 Byte for representing each of R,G,B components. Working with bitmap images required analising the structure of a file (header, DIB header, pixel array, padding).\nImplementing iterative flood fill algorithm: Given coordinates of starting pixel, add bordering pixels to queue. For each pixel in queue, if it's in the same color as starting pixel, recolor it and add bordering pixels to queue. Remove analized pixel from queue.",
            "img_paths": ["assets/images/projects/riscv_code.png", "assets/images/projects/riscv_colors.png", "assets/images/projects/riscv_binaryfile.png", "assets/images/projects/riscv_littleendian.png", "assets/images/projects/riscv_results.png"],
            "technologies": ["Assembly"],
            "github_link": "",
            "people_no": "solo",
            "goal": "university",
            "takeaways": ["programming in RISC-V Assebly", "working with bitmaps, their file structure", "reading binary form of a bitmap file (using hexed.it, little endian convention)"],
            "other": []
          },
          {
            "name": "Alpha blending in x86-64 Assembly",
            "description_short": "Blending 2 raster images together (in a sinus pattern) using x86 Assembly.",
            "description_long": "Program in C and x86-64 Assebly (NASM). In main.c I included Allegro library, prepared 2 source images as arrays of pixels, promted user for x,y coordinates of the reference point and called assembly funtion implemented in f.s.\nIt processes every pixel in first image and calculates its distance from the reference point. Based on that it calculates proper opacity (trasparentcy/opacity levels are spread in circles around the reference point) = alpha value of the first picture's pixel. It then combines it with a corresponding pixel from the second image (calculates final pixel value based on both RGB values and the alpha).\nThe program uses floating-point operations, like fsin instruction, registers, loading and storing operations, jumps, comparing instructions, is compliant with the x86 calling convention.",
            "img_paths": ["assets/images/projects/x86_result.png", "assets/images/projects/x86_code.png", "assets/images/projects/x86_gdb.png", "assets/images/projects/x86_registers.png", "assets/images/projects/x86_step1.png", "assets/images/projects/x86_step2.png", "assets/images/projects/x86_step3.png", "assets/images/projects/x86_step4.png"],
            "technologies": ["Assembly", "C", "gcc compiler", "gdb debugger"],
            "github_link": "",
            "people_no": "solo",
            "goal": "university",
            "takeaways": ["programming in x86-64 Assebly", "using and compiling C code as a hybrid mixed with assembly", "working with raster images"],
            "other": []
          },
          {
            "name": "Tents and Trees puzzle",
            "description_short": "Recreation of a logical puzzle game with board generation and user interaction in Python, Pygame.",
            "description_long": "Older project, from 02/2022, before enrolling in Computer Science classes at the university. Created without using git, with all code in one long file, with comments and variable names in Polish. A progress can be seen, from writing this game to developing current programs.\nA game created in Python using Pygame library. A window opens, the player chooses the difficulty (nr of tiles) and a plane is generated. Each tile is either blank or a Tree. Clicking on originally blank tiles changes them to a Tent or a Ground. Goal of the puzzle is to place one Tent next to every Tree, while complying to digits near each row and column (which represent the number of tents in row/column).\nThe board respecting the game rules is randomly generated. Game looks warm, cartoony, its controls are satisfying. I implemented some personal improvements like clearing the board, showing game rules, getting hint about one random tile, changing the theme."
            ,
            "img_paths": ["assets/images/projects/tentstrees_game.png", "assets/images/projects/tentstrees_home.png", "assets/images/projects/tentstrees_level.png", "assets/images/projects/tentstrees_large.png"],
            "technologies": ["Python", "Pygame"],
            "github_link": "",
            "people_no": "solo",
            "goal": "personal",
            "takeaways": ["first major project", "recreating an existing puzzle", "generating the board", "scaling tiles and icons sizes depending on board complexity", "using downloaded icons"],
            "other": []
          },
          {
            "name": "Ticket machine in console",
            "description_short": "A ticket machine written in Python, allowing buing different kinds of tickets, storing data in csv files.",
            "description_long": "A program in Python concluding Basics of Informatics and Programming class. Communication with user is held via console, information and availible options are displayed on the screen, user enters a number corresponding to wanted action.\nOptions availible in main menu are 'Change the language' (changes each message in messages dictionary to one in the chosen language - taken from csv file), 'Check status' (days left on a Long_Term_Ticket or money left on a Prepaid_Ticket), 'Recharge' (prolonging Long_Term_Ticket/adding money to Prepaid_Ticket, given ticket id) and 'Buy ticket' (with further options as buing short term/log term/prepaid ticket and buing a ticket using existing prepaid).\nAvailible options are stored as lists inside corresponding functions - as keys, code names, which will be looked up in the dictionary to find full user friendly communicate in the right language.\nAll data (language options, ticket data, user data) is stored in csv files. Funtions represent thought-out scenarios, actions chosen by the user have to exist (proving valid action nr), be possible (e.g. enough money on the ticket), be valid for given user (providing ticket id which is assigned to them). Funtions have corresponding tests, stored in test_X.py files, created using pytest framework.",
            "img_paths": ["assets/images/projects/tickets_main.png", "assets/images/projects/tickets_buy.png", "assets/images/projects/tickets_csv.png", "assets/images/projects/tickets_languages.png"],
            "technologies": ["Python", "Pytest"],
            "github_link": "",
            "people_no": "solo",
            "goal": "university",
            "takeaways": ["creating unit tests", "using csv format", "creating a system with given requirements"],
            "other": []
          },
          {
            "name": "Algorithms and Data Structures (AISDI labs)",
            "description_short": "Series of programs, implementing algorithms and data structures in Python in a 2-person team.",
            "description_long": "1. Morse encoding\n2. Implementing bubble sort, selection sort, merge sort and quick sort, comparing their performance\n3. Implementing BST and AVL trees - creating, searching, removing; Comparing both kinds of binary search trees with each other, with sorted/not sorted elements.\n4. Heaps where each node has 2/3/a children\n5. String-searching algorithms - comparing naive, KMP and KR approach\n6. Implementing graphs, Dijkstra algorithm for finding the shortest path",
            "img_paths": ["assets/images/projects/aisdi_sorting.png", "assets/images/projects/aisdi_heaps.png", "assets/images/projects/aisdi_pattern.png", "assets/images/projects/aisdi_dijkstra.png"],
            "technologies": ["Python", "Matplotlib"],
            "github_link": "",
            "people_no": "group",
            "goal": "university",
            "takeaways": ["learning sorting, pattern searching and shortest path searching algorithms", "learning about binaray search trees, heaps, graphs", "using matplotlib to show algorithm times comparisons"],
            "other": []
          },
          {
            "name": "Operating Systems (SOI labs)",
            "description_short": "Modifying operating system kernel, threads and processes operations.",
            "description_long": "Series of 6 laboratories.\n1. Creating and configuration of Linux in a virtual machine with Hyper-V. Installing Minix system image. Learning linux commands, theory of what Minix is. Using WinSCP to transfer files from host machine.\n2. Changing system kernel and compiling it. Creating new system calls (modifying minix/callnr.h, mm/proto.h, mm/misc.c, fs/table.c, mm/table.c files). Operating on process identifiers (PIDs), creating new processes using fork().\n3. Changing process scheduling algorithm (creating 3 process groups A,B,C, scheduling them so that a process get chosen sequentially from each group, processes withing groups are also chosen sequentially - e.g. A1 B1 C1 A2 B1 C2 A1 B1 C3)\n4. Threads synchronization using semaphores - consumer and producer threads with consumer priority, using p() and v() operations, direct resume and standard approach\n5. Threads synchronization using monitors - condition variables, enter, leave, wait and signal operations\n6. Memory management - changing memory allocation algorithm of choosing free block from first_fit to worst_fit, creating new system calls hole_map and worst_fit",
            "img_paths": ["assets/images/soi.png"],
            "technologies": ["Minix", "Linux", "C", "Hyper-V", "WinSCP"],
            "github_link": "",
            "people_no": "solo",
            "goal": "university",
            "takeaways": ["working with Linux, Minix", "modifying system kernel, creating new system calls", "synchronisation idea and algorithms"],
            "other": []
          },
          {
            "name": "Flutter App for Smart City Student Association",
            "description_short": "A working Flutter app still in development, with homepage, camera and location access.",
            "description_long": "I started learning Flutter for a group project in Smart City Student Association. After some work I aquired a new skill and was able to create a working prototype. The project develops thanks to the efforts of a couple of people and is still in progress, presented content is my part in it until now.\nI recreated Homepage layout from a Figma document designed by my teammate. There's a menu and a carousel widget with auto-changin photos (carousel_slider Flutter package). Clicking on corresponding menu options lauches a camera preview in the app (camera Flutter package) or localizes the device (geolocator Flutter package) and opens a map application with a pin in aquired coordinates (map_laucher Flutter package).",
            "img_paths": ["assets/images/projects/city_main.jpg", "assets/images/projects/city_menu.jpg", "assets/images/projects/city_homepage.jpg", "assets/images/projects/city_location.jpg"],
            "technologies": ["Flutter", "Dart", "Android Emulator"],
            "github_link": "",
            "people_no": "group",
            "goal": "personal",
            "takeaways": ["learning Flutter framework - widgets, buttons, themes, layouts, navigation, images, location"],
            "other": []
          },
          {
            "name": "Flutter Portfolio Website",
            "description_short": "Recreation of a logical puzzle game with board generation and user interaction.",
            "description_long": "",
            "img_paths": ["assets/images/flutter.png"],
            "technologies": ["Python", "AI"],
            "github_link": "",
            "people_no": "solo",
            "goal": "university",
            "takeaways": [""],
            "other": []
          },
          {
            "name": "Figma pap, ta strona, inne",
            "description_short": "Recreation of a logical puzzle game with board generation and user interaction.",
            "description_long": "",
            "img_paths": ["assets/images/figma.png"],
            "technologies": ["Python", "AI"],
            "github_link": "",
            "people_no": "solo",
            "goal": "university",
            "takeaways": [""],
            "other": []
          },
          {
            "name": "Śmietnik zespołowy",
            "description_short": "Recreation of a logical puzzle game with board generation and user interaction.",
            "description_long": "",
            "img_paths": ["assets/images/turn_waste.jpg"],
            "technologies": ["Python", "AI"],
            "github_link": "",
            "people_no": "solo",
            "goal": "university",
            "takeaways": [""],
            "other": []
          },
          {
            "name": "Project Title",
            "description_short": "Description, description, description, lorem ipsum dot sit amet.",
            "description_long": "",
            "img_paths": ["assets/images/empty.png"],
            "technologies": ["Python", "AI"],
            "github_link": "",
            "people_no": "solo",
            "goal": "university",
            "takeaways": [""],
            "other": []
          }
    ]
}
